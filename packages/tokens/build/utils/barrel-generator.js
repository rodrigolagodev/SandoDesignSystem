/**
 * CSS Barrel File Generator
 *
 * Generates index.css barrel files that aggregate CSS imports for easy consumption.
 * These files are auto-generated after each token build.
 *
 * Structure generated:
 * - dist/sando-tokens/css/index.css (full bundle: ingredients + original flavor + recipes)
 * - dist/sando-tokens/css/ingredients/index.css (all ingredients)
 * - dist/sando-tokens/css/flavors/index.css (original flavor only - default)
 * - dist/sando-tokens/css/flavors/{flavor}/index.css (all modes for each flavor)
 * - dist/sando-tokens/css/recipes/index.css (all recipes)
 */

import fs from 'fs';
import path from 'path';

/** Auto-generated file header */
const HEADER = `/**
 * AUTO-GENERATED FILE - DO NOT EDIT
 * Generated by: packages/tokens/build/utils/barrel-generator.js
 * Regenerate by running: pnpm build
 */

`;

/** Default flavor used in the main flavors/index.css */
const DEFAULT_FLAVOR = 'original';

/**
 * Discover CSS files in a directory (non-recursive)
 * @param {string} dir - Absolute directory path
 * @returns {string[]} Array of CSS filenames sorted alphabetically
 */
function discoverCssFiles(dir) {
  if (!fs.existsSync(dir)) {
    return [];
  }

  return fs.readdirSync(dir)
    .filter(file => file.endsWith('.css') && file !== 'index.css')
    .sort();
}

/**
 * Discover subdirectories in a directory
 * @param {string} dir - Absolute directory path
 * @returns {string[]} Array of subdirectory names sorted alphabetically
 */
function discoverSubdirectories(dir) {
  if (!fs.existsSync(dir)) {
    return [];
  }

  return fs.readdirSync(dir, { withFileTypes: true })
    .filter(entry => entry.isDirectory())
    .map(entry => entry.name)
    .sort();
}

/**
 * Generate CSS @import statements from file list
 * @param {string[]} files - Array of CSS filenames
 * @param {string} prefix - Path prefix for imports (e.g., './')
 * @returns {string} CSS content with @import statements
 */
function generateImports(files, prefix = './') {
  return files
    .map(file => `@import "${prefix}${file}";`)
    .join('\n');
}

/**
 * Write a barrel file with header and imports
 * @param {string} filePath - Absolute path to write
 * @param {string} content - CSS import content
 * @param {string} description - Description for the file header
 */
function writeBarrelFile(filePath, content, description = '') {
  const header = description
    ? HEADER.replace('AUTO-GENERATED FILE', `AUTO-GENERATED FILE - ${description}`)
    : HEADER;

  fs.writeFileSync(filePath, header + content + '\n', 'utf-8');
}

/**
 * Generate ingredients/index.css
 * Imports all ingredient CSS files
 * @param {string} cssDir - Base CSS output directory
 * @returns {number} Number of files imported
 */
function generateIngredientsBarrel(cssDir) {
  const ingredientsDir = path.join(cssDir, 'ingredients');
  const files = discoverCssFiles(ingredientsDir);

  if (files.length === 0) {
    console.log('   ‚ö†Ô∏è  No ingredient CSS files found');
    return 0;
  }

  const content = generateImports(files);
  const outputPath = path.join(ingredientsDir, 'index.css');

  writeBarrelFile(outputPath, content, 'Ingredients Bundle');
  console.log(`   üì¶ ingredients/index.css (${files.length} files)`);

  return files.length;
}

/**
 * Generate index.css for a single flavor
 * Imports all mode files in correct order: base first, then variants
 * @param {string} flavorDir - Absolute path to flavor directory
 * @param {string} flavorName - Flavor name for logging
 * @returns {number} Number of files imported
 */
function generateFlavorBarrel(flavorDir, flavorName) {
  const files = discoverCssFiles(flavorDir);

  if (files.length === 0) {
    return 0;
  }

  // Sort files: flavor.css (base) first, then variants alphabetically
  const sortedFiles = files.sort((a, b) => {
    // Base flavor file always comes first
    if (a === 'flavor.css') return -1;
    if (b === 'flavor.css') return 1;
    // Then alphabetically
    return a.localeCompare(b);
  });

  const content = generateImports(sortedFiles);
  const outputPath = path.join(flavorDir, 'index.css');

  writeBarrelFile(outputPath, content, `${flavorName} Flavor Bundle`);

  return files.length;
}

/**
 * Generate flavors/index.css and per-flavor index files
 * The main flavors/index.css only includes the default flavor (original)
 * @param {string} cssDir - Base CSS output directory
 * @returns {Object} Stats about generated files
 */
function generateFlavorsBarrel(cssDir) {
  const flavorsDir = path.join(cssDir, 'flavors');
  const flavorFolders = discoverSubdirectories(flavorsDir);

  if (flavorFolders.length === 0) {
    console.log('   ‚ö†Ô∏è  No flavor directories found');
    return { flavors: 0, totalModes: 0 };
  }

  let totalModes = 0;

  // Generate index.css for each flavor
  for (const flavor of flavorFolders) {
    const flavorDir = path.join(flavorsDir, flavor);
    const modesCount = generateFlavorBarrel(flavorDir, flavor);
    totalModes += modesCount;
    console.log(`   üé® flavors/${flavor}/index.css (${modesCount} modes)`);
  }

  // Generate main flavors/index.css (only default flavor)
  if (flavorFolders.includes(DEFAULT_FLAVOR)) {
    const content = `@import "./${DEFAULT_FLAVOR}/index.css";`;
    const outputPath = path.join(flavorsDir, 'index.css');
    writeBarrelFile(outputPath, content, `Flavors Bundle (default: ${DEFAULT_FLAVOR})`);
    console.log(`   üé≠ flavors/index.css (default: ${DEFAULT_FLAVOR})`);
  } else {
    console.log(`   ‚ö†Ô∏è  Default flavor "${DEFAULT_FLAVOR}" not found`);
  }

  return { flavors: flavorFolders.length, totalModes };
}

/**
 * Generate recipes/index.css
 * Imports all recipe CSS files
 * @param {string} cssDir - Base CSS output directory
 * @returns {number} Number of files imported
 */
function generateRecipesBarrel(cssDir) {
  const recipesDir = path.join(cssDir, 'recipes');
  const files = discoverCssFiles(recipesDir);

  if (files.length === 0) {
    console.log('   ‚ö†Ô∏è  No recipe CSS files found');
    return 0;
  }

  const content = generateImports(files);
  const outputPath = path.join(recipesDir, 'index.css');

  writeBarrelFile(outputPath, content, 'Recipes Bundle');
  console.log(`   üß© recipes/index.css (${files.length} files)`);

  return files.length;
}

/**
 * Generate root index.css
 * Full bundle: ingredients + default flavor + recipes
 * @param {string} cssDir - Base CSS output directory
 */
function generateRootBarrel(cssDir) {
  const imports = [
    '@import "./ingredients/index.css";',
    '@import "./flavors/index.css";',
    '@import "./recipes/index.css";'
  ];

  const content = imports.join('\n');
  const outputPath = path.join(cssDir, 'index.css');

  writeBarrelFile(outputPath, content, 'Full Bundle');
  console.log(`   üìã index.css (full bundle)`);
}

/**
 * Generate all CSS barrel files
 * Main entry point called after token build completes
 * @param {string} distDir - Distribution directory (e.g., 'dist/sando-tokens')
 * @returns {Object} Generation stats
 */
export async function generateCssBarrels(distDir) {
  const cssDir = path.join(distDir, 'css');

  if (!fs.existsSync(cssDir)) {
    console.log('   ‚ùå CSS output directory not found:', cssDir);
    return { success: false, error: 'CSS directory not found' };
  }

  console.log('\nüìã Generating CSS barrel files...\n');

  try {
    // Generate layer barrels
    const ingredientsCount = generateIngredientsBarrel(cssDir);
    const { flavors, totalModes } = generateFlavorsBarrel(cssDir);
    const recipesCount = generateRecipesBarrel(cssDir);

    // Generate root barrel
    generateRootBarrel(cssDir);

    console.log('');

    return {
      success: true,
      stats: {
        ingredients: ingredientsCount,
        flavors,
        totalModes,
        recipes: recipesCount
      }
    };
  } catch (error) {
    console.error('   ‚ùå Failed to generate barrel files:', error.message);
    return { success: false, error: error.message };
  }
}

/**
 * Get the default distribution directory
 * @returns {string} Absolute path to dist directory
 */
export function getDefaultDistDir() {
  return path.join(process.cwd(), 'dist', 'sando-tokens');
}
