meta:
  doc_id: "FI"
  category: "02-architecture"
  version: "1.0.0"
  status: "Active"
  last_updated: "2025-11-09"
  owner: "Ecosystem Integration Agent"

purpose:
  id: "FI-PU"
  description: |
    Defines how Sando Web Components integrate with React, Vue, Angular, and Svelte. This includes TypeScript configuration, event handling, prop passing, SSR considerations, and framework-specific patterns that ensure components work seamlessly in any framework.

core_rules:
  - id: "FI-CR-R1"
    title: "Framework-Agnostic Web Components"
    summary: "Sando components are framework-agnostic by design. They work in ANY framework because they follow the Web Components standard."
    why:
      - name: "Universal"
        note: "One codebase, all frameworks"
      - name: "Future-proof"
        note: "Standard-based, not tied to framework versions"
      - name: "Encapsulated"
        note: "Shadow DOM prevents style leaks"
      - name: "Interoperable"
        note: "Can mix React, Vue, and vanilla components"
    pattern:
      lang: "html"
      code: |
        <sando-button variant="solid">Click me</sando-button>

        <sando-button variant="solid">Click me</sando-button>

        <sando-button variant="solid">Click me</sando-button>

        <sando-button variant="solid">Click me</sando-button>

        <sando-button variant="solid">Click me</sando-button>
    anti_pattern:
      lang: "typescript"
      code: |
        // WRONG: Framework-specific components
        @sando/react     // Separate React wrappers
        @sando/vue       // Separate Vue wrappers
        // Maintenance nightmare, duplication

  - id: "FI-CR-R2"
    title: "Import Before Use"
    summary: "All frameworks require importing the component before use (side-effect import for registration)."
    pattern:
      lang: "typescript"
      code: |
        // Import component (registers custom element)
        import "@sando/components/button";

        // Now <sando-button> is available in templates
    why: "Web Components must be registered before the browser can use them. Importing triggers registration."
    anti_pattern:
      lang: "typescript"
      code: |
        // WRONG: Not importing
        // <sando-button> used in template without import
        // Browser doesn't know what <sando-button> is

  - id: "FI-CR-R3"
    title: "Properties vs Attributes"
    summary: "Understand the difference: Properties (JS objects) vs Attributes (HTML strings)."
    properties_definition:
      purpose: "Complex data (objects, arrays)"
      example:
        lang: "javascript"
        code: |
          const button = document.querySelector("sando-button");
          button.options = { variant: "solid", size: "medium" }; // Object
    attributes_definition:
      purpose: "Simple data (strings, numbers, booleans)"
      example:
        lang: "html"
        code: |
          <sando-button variant="solid" size="medium"></sando-button>
    lit_convention: "Use `reflect: true` to sync prop ↔ attribute for simple values (strings, numbers, booleans)."
    component_pattern:
      lang: "typescript"
      code: |
        @property({ reflect: true })
        variant: 'solid' | 'outline' = 'solid';  // ↔ Syncs to attribute

        @property({ type: Boolean, reflect: true })
        disabled = false;  // ↔ Syncs to attribute
    framework_impact:
      - framework: "React"
        note: "Can't pass objects as attributes (use refs)"
      - framework: "Vue"
        note: "Can use `v-bind` for properties"
      - framework: "Angular"
        note: "Use property binding `[disabled]`"
      - framework: "Svelte"
        note: "Can pass objects directly"

  - id: "FI-CR-R4"
    title: "Event Handling"
    summary: "Web Components dispatch custom events. Each framework has its own event handling syntax."
    event_dispatch_pattern:
      lang: "typescript"
      code: |
        // Component dispatches custom event
        this.dispatchEvent(
          new CustomEvent("button-click", {
            detail: { value: "data" },
            bubbles: true,
            composed: true, // ✓ Crosses shadow boundary
          })
        );
    framework_patterns:
      - framework: "React"
        syntax: "addEventListener"
        code: "buttonRef.current.addEventListener('button-click', handler);"
      - framework: "Vue"
        syntax: "@event-name"
        code: '<sando-button @button-click="handler"></sando-button>'
      - framework: "Angular"
        syntax: "(eventName)"
        code: '<sando-button (button-click)="handler($event)"></sando-button>'
      - framework: "Svelte"
        syntax: "on:event-name"
        code: '<sando-button on:button-click={handler}></sando-button>'
    why: "Events must use `composed: true` to cross Shadow DOM boundary and reach framework listeners."

  - id: "FI-CR-R5"
    title: "TypeScript Support"
    summary: "Provide TypeScript definitions for all components to enable autocomplete and type checking."
    global_types_pattern:
      lang: "typescript"
      code: |
        declare global {
          interface HTMLElementTagNameMap {
            "sando-button": SandoButton;
            "sando-card": SandoCard;
          }
        }

        // JSX types (React)
        declare namespace JSX {
          interface IntrinsicElements {
            "sando-button": React.DetailedHTMLProps<
              React.HTMLAttributes<SandoButton>,
              SandoButton
            >;
          }
        }
    benefit: "IDEs provide autocomplete for component props and events."

react_integration:
  id: "FI-REACT"
  basic_setup:
    pattern:
      lang: "typescript"
      code: |
        // 1. Import component
        import '@sando/components/button';

        // 2. Use in JSX
        function App() {
          return <sando-button variant="solid">Click me</sando-button>;
        }
  typescript_support:
    file_path: "src/types/web-components.d.ts"
    pattern:
      lang: "typescript"
      code: |
        import { SandoButton } from "@sando/components/button";

        declare global {
          namespace JSX {
            interface IntrinsicElements {
              "sando-button": React.DetailedHTMLProps<
                React.HTMLAttributes<SandoButton> & {
                  variant?: "solid" | "outline" | "ghost";
                  size?: "small" | "medium" | "large";
                  disabled?: boolean;
                },
                SandoButton
              >;
            }
          }
        }
    benefit: "Autocomplete and type checking in JSX"
  event_handling:
    approach: "Use refs + addEventListener"
    pattern:
      lang: "typescript"
      code: |
        import { useRef, useEffect } from 'react';

        function App() {
          const buttonRef = useRef<HTMLElement>(null);

          useEffect(() => {
            const button = buttonRef.current;
            if (!button) return;

            const handler = (e: Event) => {
              const customEvent = e as CustomEvent;
              console.log('Clicked:', customEvent.detail);
            };

            button.addEventListener('button-click', handler);
            return () => button.removeEventListener('button-click', handler);
          }, []);

          return <sando-button ref={buttonRef}>Click me</sando-button>;
        }
    why: "React's synthetic events don't capture custom events. Must use native addEventListener."
  complex_props:
    approach: "Use refs to set properties"
    pattern:
      lang: "typescript"
      code: |
        import { useRef, useEffect } from 'react';

        function App() {
          const componentRef = useRef<any>(null);

          useEffect(() => {
            if (componentRef.current) {
              componentRef.current.complexData = { /* object */ };
            }
          }, []);

          return <sando-component ref={componentRef}></sando-component>;
        }
    why: "Can't pass objects as attributes in React. Must set as property via ref."

vue_integration:
  id: "FI-VUE"
  basic_setup:
    config_file: "vite.config.ts"
    pattern:
      lang: "typescript"
      code: |
        import { defineConfig } from "vite";
        import vue from "@vitejs/plugin-vue";

        export default defineConfig({
          plugins: [
            vue({
              template: {
                compilerOptions: {
                  // Treat all tags starting with 'sando-' as custom elements
                  isCustomElement: (tag) => tag.startsWith("sando-"),
                },
              },
            }),
          ],
        });
    why: "Tells Vue compiler to not treat `sando-*` as Vue components"
  template_usage:
    pattern:
      lang: "vue"
      code: |
        <script setup lang="ts">
        import "@sando/components/button";

        function handleClick(e: CustomEvent) {
          console.log("Clicked:", e.detail);
        }
        </script>

        <template>
          <sando-button variant="solid" @button-click="handleClick">
            Click me
          </sando-button>
        </template>
    advantages:
      - "`@event-name` syntax for custom events"
      - "`v-bind` for properties"
      - "`v-model` can work with custom events"
  typescript_support:
    file_path: "src/types/web-components.d.ts"
    pattern:
      lang: "typescript"
      code: |
        import { SandoButton } from "@sando/components/button";

        declare module "@vue/runtime-core" {
          interface GlobalComponents {
            "sando-button": typeof SandoButton;
          }
        }
  vmodel_support:
    usage:
      lang: "vue"
      code: |
        <sando-input v-model="text"></sando-input>

        <sando-input
          :value="text"
          @value-changed="text = $event.detail.value"
        ></sando-input>
    component_implementation:
      lang: "typescript"
      code: |
        @property({ reflect: true })
        value = '';

        private handleInput(e: Event) {
          this.value = (e.target as HTMLInputElement).value;
          this.dispatchEvent(new CustomEvent('value-changed', {
            detail: { value: this.value },
            bubbles: true,
            composed: true
          }));
        }

angular_integration:
  id: "FI-ANGULAR"
  basic_setup:
    file_path: "app.module.ts"
    pattern:
      lang: "typescript"
      code: |
        import { NgModule, CUSTOM_ELEMENTS_SCHEMA } from "@angular/core";

        @NgModule({
          schemas: [CUSTOM_ELEMENTS_SCHEMA], // ✓ Allow custom elements
          // ...
        })
        export class AppModule {}
    why: "Tells Angular compiler to allow unknown HTML tags (Web Components)"
  template_usage:
    pattern:
      lang: "typescript"
      code: |
        // app.component.ts
        import { Component, OnInit } from "@angular/core";
        import "@sando/components/button"; // ✓ Import for registration

        @Component({
          selector: "app-root",
          template: `
            <sando-button variant="solid" (button-click)="handleClick($event)">
              Click me
            </sando-button>
          `,
        })
        export class AppComponent {
          handleClick(event: Event) {
            const customEvent = event as CustomEvent;
            console.log("Clicked:", customEvent.detail);
          }
        }
    event_syntax: "(event-name) for custom events"
  property_binding:
    pattern:
      lang: "html"
      code: |
        <sando-component
          [complexData]="myObject"
          [disabled]="isDisabled"
        ></sando-component>
    why: "[prop] binds to property (JS), not attribute (HTML string)"
  typescript_support:
    file_path: "typings.d.ts"
    pattern:
      lang: "typescript"
      code: |
        declare global {
          interface HTMLElementTagNameMap {
            "sando-button": any; // Or import actual type
          }
        }

svelte_integration:
  id: "FI-SVELTE"
  basic_setup:
    note: "Svelte works out of the box with Web Components. No special configuration needed."
    pattern:
      lang: "svelte"
      code: |
        <script lang="ts">
          import '@sando/components/button';

          function handleClick(e: CustomEvent) {
            console.log('Clicked:', e.detail);
          }
        </script>

        <sando-button
          variant="solid"
          on:button-click={handleClick}
        >
          Click me
        </sando-button>
    advantages:
      - "No special config needed"
      - "`on:event-name` for custom events"
      - "Can pass objects as props directly"
      - "Full TypeScript support"
  typescript_support:
    file_path: "src/ambient.d.ts"
    pattern:
      lang: "typescript"
      code: |
        declare namespace svelteHTML {
          interface IntrinsicElements {
            "sando-button": {
              variant?: "solid" | "outline" | "ghost";
              size?: "small" | "medium" | "large";
              disabled?: boolean;
            };
          }
        }
  property_binding:
    pattern:
      lang: "svelte"
      code: |
        <script>
          import '@sando/components/input';

          let value = '';
        </script>

        <sando-input
          bind:value={value}
          on:value-changed={(e) => value = e.detail.value}
        ></sando-input>

        <p>Value: {value}</p>

ssr_considerations:
  id: "FI-SSR"
  summary: "Web Components don't render server-side by default. They require JavaScript to run."
  strategies:
    - id: "FI-SSR-S1"
      name: "Declarative Shadow DOM"
      status: "experimental"
      pattern:
        lang: "html"
        code: |
          <sando-button>
            <template shadowroot="open">
              </template>
            Click me
          </sando-button>
    - id: "FI-SSR-S2"
      name: "Client-only rendering"
      pattern:
        lang: "typescript"
        framework: "Next.js"
        code: |
          import dynamic from "next/dynamic";

          const SandoButton = dynamic(
            () =>
              import("@sando/components/button").then(() => ({
                default: "sando-button",
              })),
            { ssr: false }
          );
    - id: "FI-SSR-S3"
      name: "Progressive enhancement"
      pattern:
        lang: "html"
        code: |
          <sando-button>
            <span slot="fallback">Click me</span>
          </sando-button>
  recommendation: "Use client-only rendering for SSR frameworks until Declarative Shadow DOM is widely supported."

common_patterns:
  id: "FI-CP"
  lazy_loading:
    pattern:
      lang: "typescript"
      code: |
        // Load component on demand
        async function loadButton() {
          await import("@sando/components/button");
          // <sando-button> now available
        }
  conditional_rendering:
    - framework: "React"
      lang: "tsx"
      code: "{showButton && <sando-button>Click</sando-button>}"
    - framework: "Vue"
      lang: "vue"
      code: '<sando-button v-if="showButton">Click</sando-button>'
    - framework: "Angular"
      lang: "html"
      code: '<sando-button *ngIf="showButton">Click</sando-button>'
    - framework: "Svelte"
      lang: "svelte"
      code: |
        {#if showButton}
          <sando-button>Click</sando-button>
        {/if}
  slots:
    summary: "All frameworks support slots for content projection"
    pattern:
      lang: "html"
      code: |
        <sando-card>
          <span slot="header">Title</span>
          <p>Content goes here</p>
          <div slot="footer">Actions</div>
        </sando-card>
    framework_specific:
      - framework: "React"
        lang: "jsx"
        code: |
          <sando-card>
            <span slot="header">Title</span>
            <p>Content</p>
          </sando-card>
      - framework: "Vue"
        lang: "vue"
        code: |
          <sando-card>
            <template v-slot:header>
              <span>Title</span>
            </template>
            <p>Content</p>
          </sando-card>

related_guidelines:
  - type: "guideline"
    doc_id: "CA"
    file: "COMPONENT_ARCHITECTURE.toon"
    category: "02-architecture"
    note: "Component structure, Shadow DOM, event patterns"
  - type: "guideline"
    doc_id: "CD"
    file: "../01-design-system/COMPONENT_DESIGN.toon"
    category: "01-design-system"
    note: "Component API conventions"
  - type: "guideline"
    doc_id: "MS"
    file: "MONOREPO_STRUCTURE.toon"
    category: "02-architecture"
    note: "Package exports, build system"

external_references:
  - type: "standard"
    url: "httpss://developer.mozilla.org/en-US/docs/Web/Web_Components"
    title: "Web Components - MDN"
    note: "Web Components standard documentation"
  - type: "tool"
    url: "httpss://custom-elements-everywhere.com/"
    title: "Custom Elements Everywhere"
    note: "Framework compatibility tests"
  - type: "documentation"
    url: "httpss://lit.dev/docs/frameworks/overview/"
    title: "Lit - Framework Integration"
    note: "Official Lit framework integration guide"
  - type: "documentation"
    url: "httpss://react.dev/reference/react-dom/components#custom-html-elements"
    title: "React - Web Components"
    note: "React Web Components documentation"
  - type: "documentation"
    url: "httpss://vuejs.org/guide/extras/web-components.html"
    title: "Vue - Web Components"
    note: "Vue Web Components integration"
  - type: "documentation"
    url: "httpss://angular.io/guide/elements"
    title: "Angular - Web Components"
    note: "Angular Elements guide"

conclusion: |
  This guideline ensures Sando Web Components work seamlessly across all major frameworks. The key principle: components are framework-agnostic by design, with framework-specific configuration for optimal integration.